#!/usr/bin/python2.7
"""Tool for inferring types from Python programs.

'pytype' is a tool for generating pytd from Python programs.

Usage:
  pytype [flags] file.py
"""

import logging
import optparse
import os
import sys

from pytype import infer
from pytype.pytd import optimize
from pytype.pytd import pytd
from pytype.pytd import utils as pytd_utils


log = logging.getLogger(__name__)


# The input files will typically end with ".py".

# There may also be input files that end with ".pytd" -- these are PyTD and are
# used to supplement function annotations (e.g., for Python2 source) -- they are
# similar to PEP 484 "stubs" but with a different syntax; and we'll eventually
# switch to PEP 484 syntax.

# TODO(pludemann): Add this to the pytype documentation:
# TODO(pludemann): 2017-07-14: Merging .py and .pytd inputs not yet implemented
#
# If you use .pytd for output files and also have .pytd inputs, you should be
# careful to distinguish the two usages, and consider using a different file
# extension for output from pytype (e.g., .pytd-gen).  The output from pytype is
# "complete" ... that is, it is made up of a combination of the function
# annotations and inferences, and has an entry for every function, method,
# global variable. If you have hand-crafted a .pytd, it does not need to be
# "complete" but will be used to specify type annotations that pytype will only
# verify and won't try to infer.


DEFAULT_PYTD_IMPORT_EXT = ".pytd"


def _parse_options(args):
  """Use optparse to parse command line options."""
  o = optparse.OptionParser(
      description="Infer/check types in a Python module")
  o.set_defaults(optimize=True)
  o.set_defaults(api=True)
  o.add_option(
      "-o", "--output", type="string", action="store",
      dest="output", default=None,
      help=("Output file (default: <filename>%s or whatever "
            "is specified by --pytd_import_ext). "
            "Implies -f. "
            "Use '-' for stdout.") % DEFAULT_PYTD_IMPORT_EXT)
  o.add_option(
      "-f", "--force", action="store_true",
      dest="force", default=False,
      help="Overwrite (change) existing .pytd files even without -o.")
  o.add_option(
      "-V", "--python_version", type="string", action="store",
      dest="python_version", default="2.7",
      help=("Python version to emulate (\"major.minor\", e.g. \"2.7\")"))
  o.add_option(
      "-v", "--verbosity", type="int", action="store",
      dest="verbosity", default=1,
      help=("Set logging verbosity: "
            "-1=quiet, 0=fatal, 1=error (default), 2=warn, 3=info, 4=debug"))
  o.add_option(
      "-O", "--optimize", action="store_true",
      dest="optimize",
      help=("Optimize generated pytd (default)."))
  o.add_option(
      "-R", "--raw", action="store_false",
      dest="optimize",
      help=("Do not optimize generated pytd"))
  o.add_option(
      "-A", "--api", action="store_true",
      dest="api",
      help=("Analyze all functions and classes, "
            "also those not called from anywhere (default)."))
  o.add_option(
      "-m", "--main", action="store_false",
      dest="api",
      help=("Only analyze the main method and everything called from it"))
  o.add_option(
      "-S", "--structural", action="store_true",
      dest="structural", default=False,
      help=("Analyze all functions and classes, also those not called from "
            "anywhere. Output the result in structural form."))
  o.add_option(
      "-K", "--keep-unknowns", action="store_false",
      dest="solve_unknowns", default=True,
      help=("Keep 'unknown' classes generated during the first analysis pass."))
  o.add_option(
      "--no-native-builtins", action="store_false",
      dest="run_builtins", default=True,
      help=("Run the program without the native Python builtins preloaded."))
  o.add_option(
      "-B", "--builtins", type="string", action="store",
      dest="pybuiltins_filename", default=None,
      help=("Use user-supplied custom definition of __builtin__.py "
            "(for debugging). This should be an absolute file name; "
            "if it is not an absolute file name, it is resolved using "
            "--pythonpath. "
            "The default resolves to pytd/builtins/__builtin__.py. "
            "Note that this does not affect the PyTD for builtins, which "
            "is always in pytd/builtins/__builtin__.pytd."))
  o.add_option(
      "--output-cfg", type="string", action="store",
      dest="output_cfg", default=None,
      help="Output control flow graph as SVG.")
  o.add_option(
      "--output-typegraph", type="string", action="store",
      dest="output_typegraph", default=None,
      help="Output typegraph as SVG.")
  o.add_option(
      "--output-pseudocode", type="string", action="store",
      dest="output_pseudocode", default=None,
      help="Output pseudo code.")
  o.add_option(
      "-r", "--reverse-operators", action="store_true",
      dest="reverse_operators", default=False,
      help=("Enable support for Python reverse "
            "operator overloading (__radd__ etc.)"))
  o.add_option(
      "-N", "--no-cache-unknowns", action="store_false",
      dest="cache_unknowns", default=True,
      help="Do slower and more precise processing of unknown types.")
  o.add_option(
      "--irascible", type="int", action="store",
      dest="irascible", default=None,
      help="Non-zero return code: 0=critical, 1=error, 2=warn, ...")
  o.add_option(
      "--pythonpath", type="string", action="store",
      dest="pythonpath", default="",
      help=("Directories for reading dependencies - a list of paths "
            "separated by '%s'. The files must have been "
            "generated by running pytype on depdencies of the file(s) "
            "being analyzed. That is, if an input .py file has an "
            "'import path.to.foo', and pytype has already been run with "
            "'pytype path.to.foo.py -o $GENDIR/path/to/foo%s', then "
            "pytype should be invoked with $GENDIR in --pythonpath.") % (
                os.pathsep, DEFAULT_PYTD_IMPORT_EXT))
  o.add_option(  # TODO(pludemann): might want list of suffixes
      "--pytd_import_ext", type="string", action="store",
      dest="pytd_import_ext",
      default=DEFAULT_PYTD_IMPORT_EXT,
      help=("Extention to use when looking up import PyTD files in pythonpath. "
            "Also used to create output file name if --output not specified. "
            "The value should start with '.'. "
            "Default is '%s'.") % DEFAULT_PYTD_IMPORT_EXT)
  o.add_option(
      "--import_drop_prefixes", type="string", action="store",
      dest="import_drop_prefixes",
      default="",
      help=("List of prefixes to be dropped when resolving module names "
            "in import statements. The items are separated by '%s'. "
            "The individual items may contain '.'. "
            "The intended usecase is for when you're running tests in "
            "a directory structure that starts below the root module in "
            "your module names.") % os.pathsep)

  options, input_filenames = o.parse_args(args)
  return options, input_filenames


class TrackLevel(logging.Handler):

  def __init__(self):
    super(TrackLevel, self).__init__()
    self.max_level = logging.NOTSET

  def emit(self, record):
    self.max_level = max(self.max_level, record.levelno)


def _write_result(options, input_filename, result):
  """Write result to options.output or filename derived from input_filename."""
  if options.output:
    output_filename = options.output
    should_write = True
  else:
    output_filename = os.path.splitext(
        input_filename)[0] + options.pytd_import_ext
    if options.force or not os.path.exists(output_filename):
      should_write = True
    else:
      should_write = False
      if _file_contents_equals(output_filename, result):
        log.warn("%s is unchanged (--force isn't specified)",
                 output_filename)
      else:
        log.critical("%s already exists. Use --force to overwrite",
                     output_filename)
  if should_write:
    log.info("Writing output to %s", output_filename)
    with open(output_filename, "w") as fi:
      fi.write(result)


def _file_contents_equals(output_filename, contents):
  """Return True if file exists and has contents."""
  if os.path.isfile(output_filename):
    with open(output_filename, "rb") as fi:
      return fi.read() == contents
  else:
    return False


def main(argv):
  log_level_tracker = TrackLevel()
  options, input_filenames = _parse_options(argv)
  unused_executable = input_filenames.pop(0)
  if len(input_filenames) < 1:
    print >> sys.stderr, "Need at least one filename."
    sys.exit(1)
  elif len(input_filenames) >= 2:
    print >> sys.stderr, "Analyzing multiple files not yet supported:"
    print >> sys.stderr, " ".join(input_filenames)
    sys.exit(1)

  input_filename, = input_filenames

  log_levels = [logging.CRITICAL, logging.ERROR, logging.WARNING,
                logging.INFO, logging.DEBUG]
  if options.verbosity >= 0:
    if options.verbosity >= len(log_levels):
      print >> sys.stderr, "Invalid verbosity: %d" % options.verbosity
      sys.exit(1)
    logging.basicConfig(level=log_levels[options.verbosity])
  else:
    # "verbosity=-1" can be used to disable all logging, so configure logging
    # accordingly.
    logging.basicConfig(level=logging.CRITICAL + 1)

  if (options.irascible is not None and
      options.irascible < -1 or options.irascible > len(log_levels)):
    print >> sys.stderr, "Invalid irascible: %d" % options.irascible
    sys.exit(1)

  logging.getLogger().addHandler(log_level_tracker)

  # TODO(pludemann): remove abspath (it's useful for debugging)
  pythonpath = [os.path.abspath(f)
                for f in options.pythonpath.split(os.pathsep) if f]

  import_drop_prefixes = [
      p for p in options.import_drop_prefixes.split(os.pathsep) if p]

  with open(input_filename, "r") as fi:
    src = fi.read()

  python_version = tuple(map(int, options.python_version.split(".")))
  if len(python_version) != 2:
    log.error("--python_version must be <major>.<minor>")
    sys.exit(1)

  if not options.pytd_import_ext.startswith("."):
    raise ValueError("--pytd_import_ext must start with '.': '%s'" %
                     (options.pytd_import_ext,))
  if len(options.pytd_import_ext) <= 1:
    raise ValueError("invalid --pytd_import_ext '%s'" %
                     (options.pytd_import_ext,))

  for d in pythonpath:
    if not os.path.isdir(d):
      raise ValueError("--pythonpath item is not a directory: '%s" % (d,))

  mod = infer.infer_types(
      src,
      python_version=python_version,
      filename=input_filename,
      run_builtins=options.run_builtins,
      pybuiltins_filename=options.pybuiltins_filename,
      pythonpath=pythonpath,
      pytd_import_ext=options.pytd_import_ext,
      import_drop_prefixes=import_drop_prefixes,
      deep=options.api or options.structural,
      solve_unknowns=options.solve_unknowns or options.api,
      output_cfg=options.output_cfg,
      output_typegraph=options.output_typegraph,
      output_pseudocode=options.output_pseudocode,
      reverse_operators=options.reverse_operators,
      cache_unknowns=options.cache_unknowns)

  if options.optimize:
    mod = optimize.Optimize(mod,
                            # TODO(kramm): Add FLAGs for these
                            lossy=False,
                            use_abcs=False,
                            max_union=7,
                            remove_mutable=False)
    log.info("=========== PyTD optimized =============\n%s", pytd.Print(mod))
  else:
    log.info("=========== PyTD =============\n%s", pytd.Print(mod))
  log.info("========================================")

  result = pytd.Print(pytd_utils.CanonicalOrdering(mod))
  if not result.endswith("\n"):  # TODO(pludemann): fix this hack
    result += "\n"

  if options.output == "-":
    sys.stdout.write(result)
  else:
    _write_result(options, input_filename, result)

  if (options.irascible is not None and
      log_level_tracker.max_level >= log_levels[options.irascible]):
    log.critical("Maximum log message %s >= %s",
                 logging.getLevelName(log_level_tracker.max_level),
                 logging.getLevelName(log_levels[options.irascible]))
    sys.exit(1)


if __name__ == "__main__":
  main(sys.argv)
