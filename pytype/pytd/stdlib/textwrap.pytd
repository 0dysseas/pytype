# TODO(pludemann): review this -- it was generated by:
#         pytype --api python_runtime/v2_7/Lib/textwrap.py

__all__ = ...  # type: list[str]
__revision__ = ...  # type: str
_leading_whitespace_re = ...  # type: ?
_unicode = ...  # type: type
_whitespace = ...  # type: str
_whitespace_only_re = ...  # type: ?
re = ...  # type: module
string = ...  # type: module

def dedent(text) -> ?
def fill(text: unicode or str, ...) -> str
def wrap(text: unicode, ...) -> list[str]

class TextWrapper(nothing):
    __doc__ = ...  # type: str
    break_long_words = ...  # type: ?
    break_on_hyphens = ...  # type: ?
    drop_whitespace = ...  # type: ?
    expand_tabs = ...  # type: ?
    fix_sentence_endings = ...  # type: ?
    initial_indent = ...  # type: buffer or bytearray or str or unicode
    replace_whitespace = ...  # type: ?
    sentence_end_re = ...  # type: ?
    subsequent_indent = ...  # type: buffer or bytearray or str or unicode
    unicode_whitespace_trans = ...  # type: dict[nothing, nothing]
    uspace = ...  # type: int
    whitespace_trans = ...  # type: ?
    width = ...  # type: float or int or long
    wordsep_re = ...  # type: bytearray or str or unicode
    wordsep_re_uni = ...  # type: bytearray or str or unicode
    wordsep_simple_re = ...  # type: bytearray or str or unicode
    wordsep_simple_re_uni = ...  # type: bytearray or str or unicode
    def __init__(self, ...) -> NoneType
    def _fix_sentence_endings(self, chunks: dict[int, object] or list[object]) -> NoneType
    def _handle_long_word(self, reversed_chunks: list[str or unicode], cur_line: list[str or unicode], cur_len: int, width: float or int or long) -> NoneType
    def _handle_long_word(self, reversed_chunks: list[str or unicode or dict[?, ?]], cur_line: bytearray or list[object], cur_len: bool or float or int or long, width: float or int or long) -> NoneType
    def _munge_whitespace(self, text: unicode) -> unicode
    def _split(self, text) -> list[str or unicode]
    def _wrap_chunks(self, chunks: list[str or unicode]) -> list[bytearray or str or unicode]
    def fill(self, text: unicode) -> str
    def wrap(self, text: unicode) -> list[bytearray or str or unicode]

