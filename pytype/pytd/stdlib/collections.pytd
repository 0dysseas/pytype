# TODO(pludemann): review this -- it was generated by:
#         pytype --api python_runtime/v2_7/Lib/atexit.py


__all__ = ...  # type: list[?]
_abcoll = ...  # type: ?
_chain = ...  # type: type
_class_template = ...  # type: str
_eq = ...  # type: ?
_field_template = ...  # type: str
_get_ident = ...  # type: ?
_heapq = ...  # type: ?
_imap = ...  # type: type
_iskeyword = ...  # type: ?
_itemgetter = ...  # type: function
_repeat = ...  # type: type
_repr_template = ...  # type: str
_starmap = ...  # type: type
_sys = ...  # type: module
deque = ...  # type: ?
dumps = ...  # type: function
loads = ...  # type: function

Container = ... # type: ?
Hashable = ... # type: ?
Iterable = ... # type: ?
Iterator = ... # type: ?
Sized = ... # type: ?
Callable = ... # type: ?
Sequence = ... # type: ?
MutableSequence = ... # type: ?
Set = ... # type: ?
MutableSet = ... # type: ?
Mapping = ... # type: ?
MutableMapping = ... # type: ?
MappingView = ... # type: ?
ItemsView = ... # type: ?
KeysView = ... # type: ?
ValuesView = ... # type: ?

def namedtuple(typename: str, field_names: str or list[str], ...) -> type  # TODO(pludemann): add verbose, rename

class OrderedDict(object):
  pass

# TODO(kramm): Make into a Generic.
class defaultdict(object):
    def __init__(self, ...) -> NoneType
    def __contains__(self, k) -> bool
    def __delitem__(self, y) -> NoneType
    def __eq__(self, y: dict) -> bool
    def __getitem__(self, index) -> ?
    def __iter__(self) -> `dictionary-keyiterator`[?]
    def __len__(self) -> int
    def __ne__(self, y: dict) -> bool
    def __setitem__(self, i, y) -> NoneType
    def clear(self) -> NoneType
    def copy(self) -> defaultdict
    def get(self, k, default=...) -> ?
    def has_key(self, k) -> bool
    def items(self) -> list[tuple[?]]
    def iteritems(self) -> `dictionary-itemiterator`[?, ?]
    def iterkeys(self) -> `dictionary-keyiterator`[?]
    def itervalues(self) -> `dictionary-valueiterator`[?]
    def keys(self) -> list[?]
    def pop(self, k) -> ?
    def pop(self, k, d) -> ?
    def popitem(self) -> tuple[?]
    def setdefault(self, k: ?) -> ?
    def update(self, ...) -> NoneType
    def values(self) -> list[?]
    def viewitems(self) -> dict_items[?, ?]
    def viewkeys(self) -> dict_keys[?]
    def viewvalues(self) -> dict_values

# Strictly speaking, this should be dict[?, ?]. (E.g. it's legal to do
# collections.Counter()[x] = 'foobar'.) But the counts are typically integers.
class Counter(dict[?, int]):
    __doc__ = ...  # type: str
    fromkeys = ...  # type: classmethod
    def __add__(self, other: dict[object, object]) -> Counter or NotImplementedType
    def __and__(self, other: bytearray or xrange or dict[?, object] or list[object] or tuple[object]) -> Counter or NotImplementedType
    def __delitem__(self, elem) -> NoneType
    def __init__(self, ...) -> NoneType
    def __missing__(self, key) -> int
    def __or__(self, other: dict[object, object]) -> Counter or NotImplementedType
    def __reduce__(self) -> tuple[?]
    def __repr__(self) -> str
    def __sub__(self, other: dict[object, object]) -> Counter or NotImplementedType
    def copy(self) -> ?
    def elements(self) -> ?
    def most_common(self, ...) -> ?
    def subtract(self, ...) -> NoneType
    def update(self, ...) -> NoneType
