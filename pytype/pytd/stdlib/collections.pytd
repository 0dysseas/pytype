# TODO(pludemann): review this -- it was generated by:
#         pytype --api python_runtime/v2_7/Lib/atexit.py


__all__ = ...  # type: list[?]
_abcoll = ...  # type: ?
_chain = ...  # type: type
_class_template = ...  # type: str
_eq = ...  # type: ?
_field_template = ...  # type: str
_get_ident = ...  # type: ?
_heapq = ...  # type: ?
_imap = ...  # type: type
_iskeyword = ...  # type: ?
_itemgetter = ...  # type: function
_repeat = ...  # type: type
_repr_template = ...  # type: str
_starmap = ...  # type: type
_sys = ...  # type: module
deque = ...  # type: ?
dumps = ...  # type: function
loads = ...  # type: function

def namedtuple(typename: str, field_names: str or list[str], ...) -> type  # TODO(pludemann): add verbose, rename

class OrderedDict:
  pass

class defaultdict:
  def __init__(self, ...) -> NoneType

# Strictly speaking, this should be dict[?, ?]. (E.g. it's legal to do
# collections.Counter()[x] = 'foobar'.) But the counts are typically integers.
class Counter(dict[?, int]):
    __doc__ = ...  # type: str
    fromkeys = ...  # type: classmethod
    def __add__(self, other: dict[object, object]) -> Counter or NotImplementedType
    def __and__(self, other: bytearray or xrange or dict[?, object] or list[object] or tuple[object]) -> Counter or NotImplementedType
    def __delitem__(self, elem) -> NoneType
    def __init__(self, ...) -> NoneType
    def __missing__(self, key) -> int
    def __or__(self, other: dict[object, object]) -> Counter or NotImplementedType
    def __reduce__(self) -> tuple[?]
    def __repr__(self) -> str
    def __sub__(self, other: dict[object, object]) -> Counter or NotImplementedType
    def copy(self) -> ?
    def elements(self) -> ?
    def most_common(self, ...) -> ?
    def subtract(self, ...) -> NoneType
    def update(self, ...) -> NoneType
