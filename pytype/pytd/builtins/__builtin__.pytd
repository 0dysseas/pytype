from typing import (
    AbstractSet, AnyStr, BinaryIO, Callable, Dict, FrozenSet, Generator,
    Generic, Iterable, Iterator, List, Mapping, Optional, Reversible, Sequence,
    Set, Sized, SupportsAbs, SupportsFloat, SupportsInt, Tuple, Type, Union)

# "_T", "_K", and "_V" are hardcoded in abstract.py
_T = TypeVar('_T')
_T2 = TypeVar('_T2')
_T3 = TypeVar('_T3')
_T4 = TypeVar('_T4')
_K = TypeVar('_K')
_V = TypeVar('_V')
_K2 = TypeVar('_K2')
_V2 = TypeVar('_V2')
_NUMBER = TypeVar('_NUMBER', bound=complex)

def __import__(name: str or unicode or bytearray, ...) -> module
def abs(x) -> ?
def all(iterable) -> bool
def any(iterable) -> bool
def apply(object: Callable, ...) -> NoneType
def bin(number: int or float) -> str
def callable(obj) -> bool
def chr(i: int) -> str
def cmp(x, y) -> int
def coerce(x: int, y: int) -> tuple[int, int]
def coerce(x: int or float, y: float) -> tuple[float, float]
def coerce(x: int or float or complex, y: complex) -> tuple[complex, complex]
def coerce(x: float, y: int) -> tuple[float, float]
def coerce(x, y) -> tuple[object, object]
def coerce(x: list[_T], y: list[_T]) -> tuple[list[_T], list[_T]]
def coerce(x: tuple[_T, ...], y: tuple[_T, ...]) -> tuple[tuple[_T, ...], tuple[_T, ...]]
def coerce(x: complex, y: int or float) -> tuple[complex, complex]
def coerce(x: Callable, y: Callable) -> tuple[Callable, Callable]
def coerce(x: type, y: type) -> tuple[type, type]
def coerce(x: _T, y: _T) -> tuple[_T, _T]  # E.g. coerce([], [1]) -> ([], [1])
def compile(source, filename: unicode, mode: str, flags: int = ..., dont_inherit: int = ...) -> code: ...
def delattr(object, name: str or unicode or bytearray) -> None
def dir(...) -> list[str]
def divmod(x: int, y: int) -> tuple[int, int]
def divmod(x: int or float, y: int or float) -> tuple[float, float]
def divmod(x: int or float or complex, y: int or float or complex) -> tuple[complex, complex]
def eval(src, ...) -> ?  # Can't say *anything* about the result -- different from "-> object"
def execfile(filename: str, ...) -> NoneType
def filter(function: Optional[Callable[[AnyStr], ?]], iterable: AnyStr) -> AnyStr
def filter(function: Optional[Callable[[_T], ?]], iterable: Tuple[_T, ...]) -> Tuple[_T, ...]
def filter(function: Optional[Callable[[_T], ?]], iterable: Iterable[_T]) -> List[_T]
def format(value, ...) -> str
def format(value: unicode, ...) -> unicode
def getattr(value: object, attr: str or unicode, ...) -> ?
def globals() -> dict[str, ?]
def hasattr(object, name: str or unicode or bytearray) -> bool
def hash(obj) -> int
def hex(number: int) -> str
def id(obj) -> int
def intern(string: str or bytearray) -> str
def isinstance(object, class_or_type_or_tuple: tuple[type, ...] or type) -> bool
def issubclass(cls: type, class_or_type_or_tuple: tuple[type, ...] or type) -> bool
def iter(collection: bytearray) -> bytearray_iterator
def iter(collection: list[_T]) -> listiterator[_T]
def iter(collection: tuple[_T, ...]) -> tupleiterator[_T]
def iter(collection: set[_T]) -> setiterator[_T]
def iter(collection: dict[_T, _T2]) -> `dictionary-keyiterator`[_T]
def iter(collection: Generator[_T]) -> Generator[_T]
def iter(collection: Iterable[_T]) -> Iterator[_T]
def iter(func: typing.Callable[[], Union[_T, _T2]], sentinel: _T) -> `callable-iterator`[_T2]
def len(obj) -> int
def locals() -> dict[str, object]
def map(function, sequence: list[nothing], ...) -> list[nothing]
def map(function, sequence, ...) -> list
def max(iterable: Iterable[_T], key: Callable = ...) -> _T
def max(arg1: _T, arg2: _T2, *, key: Callable = ...) -> _T or _T2
def max(arg1: _T, arg2: _T2, arg3: _T3, *, key: Callable = ...) -> _T or _T2 or _T3
def max(arg1: _T, arg2: _T2, arg3: _T3, arg4: _T4, *, key = Callable) -> _T or _T2 or _T3 or _T4
def max(arg1: _T, arg2: _T, arg3: _T, arg4: _T, arg5: _T, *args: _T, key: Callable = ...) -> _T
def min(iterable: Iterable[_T], key: Callable = ...) -> _T
def min(arg1: _T, arg2: _T2, *, key: Callable = ...) -> _T or _T2
def min(arg1: _T, arg2: _T2, arg3: _T3, *, key: Callable = ...) -> _T or _T2 or _T3
def min(arg1: _T, arg2: _T2, arg3: _T3, arg4: _T4, *, key = Callable) -> _T or _T2 or _T3 or _T4
def min(arg1: _T, arg2: _T, arg3: _T, arg4: _T, arg5: _T, *args: _T, key: Callable = ...) -> _T
def next(iterator: Iterator[_T], default: _T2 = ...) -> _T or _T2
def oct(number: int) -> str
def open(name: str or buffer or unicode, ...) -> file
def ord(c: str or unicode) -> int
def pow(x: int, y: int, ...) -> float or int
def pow(x: int or float or complex, y: complex, ...) -> complex
def pow(x: int or float, y: float, ...) -> float
def pow(x: float, y: int, ...) -> float
def pow(x: complex, y: int or float, ...) -> complex
def range(stop: int, ...) -> list[int]
def reduce(function: Callable[..., _T], iterable: Iterable[_T2]) -> _T or _T2
def reduce(function: Callable, iterable: Iterable[nothing], initial: _T) -> _T
def reduce(function: Callable[..., _T], iterable: Iterable, initial) -> _T
# No reload() in Python3
def reload(mod: module) -> module
def repr(x) -> str
def round(number: int or float or typing.SupportsRound, ...) -> float
def setattr(object, name: str or unicode or bytearray, value) -> NoneType
def sorted(iterable: Iterable[_T], ...) -> list[_T]
def sum(iterable: Iterable[_NUMBER]) -> _NUMBER
def sum(iterable: Iterable[_T], start: _T) -> _T
def unichr(i: int) -> unicode
def vars(...) -> dict[str, ?]
def zip() -> list[nothing]
def zip(seq1: Iterable[nothing]) -> List[nothing]
def zip(seq1: Iterable[_T]) -> List[Tuple[_T]]
def zip(seq1: Iterable[nothing], seq2: Iterable) -> List[nothing]
def zip(seq1: Iterable, seq2: Iterable[nothing]) -> List[nothing]
def zip(seq1: Iterable[_T], seq2: Iterable[_T2]) -> List[Tuple[_T, _T2]]
def zip(seq1, seq2, seq3, ...) -> List[tuple]
def exit(code: ? = ...) -> NoneType:
    raise SystemExit()
def quit() -> NoneType:
    raise SystemExit()
def input() -> ?
def raw_input(prompt: str or unicode = ...) -> str:
    raise EOFError()
def print(...) -> NoneType

False = ...  # type: bool
True = ...  # type: bool
NotImplemented = ...  # type: NotImplementedType
None = ...  # type: NoneType
Ellipsis = ...  # type: ellipsis
__debug__ = ...  # type: bool

class object():
    __bases__ = ...  # type: Tuple[?, ...]
    __dict__ = ...  # type: Dict[str, ?]
    __doc__ = ...  # type: str
    __mro__ = ...  # type: list[?]
    __name__ = ...  # type: str
    __subclasses__ = ...  # type: ?
    __subclasshook__ = ...  # type: ?
    # InterpreterClass will contain this, too:
    __module__ = ...  # type: str
    def __init__(self) -> NoneType
    # Used by special_builtins.Object to handle super.__init__.
    def __init__extra_args(self, *args, **kwargs) -> NoneType
    def __sizeof__(self) -> int
    def __str__(self) -> str
    def __repr__(self) -> str
    def __cmp__(self, y) -> bool
    def __eq__(self, other) -> bool
    def __ne__(self, other) -> bool
    def __ge__(self, other) -> bool
    def __gt__(self, other) -> bool
    def __le__(self, other) -> bool
    def __lt__(self, other) -> bool
    def __hash__(self) -> int
    def __setattr__(self, name, value) -> None
    def __getattribute__(self, name) -> ?
    def __new__(cls: Type[_T]) -> _T
    # Used by special_builtins.Object to handler super.__new__.
    @staticmethod
    def __new__extra_args(cls: Type[_T], *args, **kwargs) -> _T

# old style class. classobj is in fact a subclass of object in Python.
class classobj(object):
    __bases__ = ...  # type: Tuple[?, ...]
    __dict__ = ...  # type: Dict[str, ?]
    __doc__ = ...  # type: str
    __name__ = ...  # type: str
    def __init__(self) -> NoneType
    def __repr__(self) -> str
    def __cmp__(self, y) -> bool

class NotImplementedType(object):
    pass

class NoneType(object):
    pass

class ellipsis(object):
    pass

class basestring(object):
    pass

class property(object):  # Also defined in __builtin__.py
    def __init__(self, fget=..., fset=..., fdel=..., doc=...) -> NoneType
    def __get__(self, ...) -> ?
    def __set__(self, ...) -> ?
    def __delete__(self, ...) -> ?

# TODO(kramm): This is wrong. These classes shouldn't inherit from
# Callable. We should instead generate the right information in pyi (I.e.,
# decorate classes instead of creating constants of type {class,static}method)
class staticmethod(typing.Callable):  # Also defined in __builtin__.py
    def __init__(self, func) -> NoneType
    def __get__(self, ...) -> ?

class classmethod(typing.Callable):  # Also defined in __builtin__.py
    def __init__(self, func) -> NoneType
    def __get__(self, ...) -> ?

_T_str = TypeVar('_T_str', bound=str)
class str(basestring, Sequence[str]):
    def __init__(self, object) -> NoneType
    def __init__(self) -> NoneType
    # TODO(rechen): Look into using AnyStr for __add__ once our solving of
    # unknowns takes TypeVar constraints into account.
    def __add__(self, y: str) -> str
    def __add__(self, y: bytearray) -> bytearray
    def __add__(self, y: unicode) -> unicode
    def __contains__(self, y: basestring) -> bool
    def __getitem__(self, index: int or slice) -> str
    def __getslice__(self, i: Optional[int], j: Optional[int]) -> str
    def __len__(self) -> int
    def __mod__(self, y) -> str
    def __mul__(self, n: int) -> str
    def capitalize(self) -> str
    def center(self, width: int, ...) -> str
    def count(self, sub: basestring or bytearray, ...) -> int
    def decode(self, ...) -> unicode
    def encode(self, ...) -> str
    def endswith(self, suffix: basestring or bytearray or tuple[basestring or bytearray, ...], ...) -> bool
    def expandtabs(self, ...) -> str
    def find(self, sub: basestring or bytearray, ...) -> int
    def format(self, ...) -> str
    def index(self, sub: basestring or bytearray, ...) -> int
    def isalnum(self) -> bool
    def isalpha(self) -> bool
    def isdigit(self) -> bool
    def islower(self) -> bool
    def isspace(self) -> bool
    def istitle(self) -> bool
    def isupper(self) -> bool
    def join(self, iterable: Iterable[nothing]) -> str
    def join(self, iterable: Iterable[str]) -> str
    def join(self, iterable: Iterable[unicode]) -> unicode
    def ljust(self, width: int, ...) -> str
    def lower(self) -> str
    def lstrip(self, ...) -> str
    def partition(self, sep: str or bytearray) -> tuple[str, str, str]
    def partition(self, sep: unicode) -> tuple[unicode, unicode, unicode]
    def replace(self, old: str or bytearray, new: str or bytearray, ...) -> str
    def replace(self, old: basestring or bytearray, new: basestring or bytearray, ...) -> unicode
    def rfind(self, sub: basestring or bytearray, ...) -> int
    def rindex(self, sub: basestring or bytearray, ...) -> int
    def rjust(self, width: int, ...) -> str
    def rpartition(self, sep: str or bytearray) -> tuple[str, str, str]
    def rpartition(self, sep: unicode) -> tuple[unicode, unicode, unicode]
    def rsplit(self, ...) -> list[str]
    def rstrip(self, ...) -> str
    def split(self, ...) -> list[str]
    def splitlines(self, ...) -> list[str]
    def startswith(self, prefix: basestring or bytearray or Iterable[basestring or bytearray], ...) -> bool
    def strip(self, ...) -> str
    def swapcase(self) -> str
    def title(self) -> str
    def translate(self, table: str) -> str
    def translate(self, table: unicode) -> unicode
    def translate(self, table: str or NoneType, deletechars: str) -> str
    def upper(self) -> str
    def zfill(self, width: int) -> str
    def __new__(cls: Type[_T_str], y = ...) -> _T_str

bytes = str

class unicode(basestring, Sequence[unicode]):
    def __init__(self, string, ...) -> NoneType
    def __init__(self) -> NoneType
    def __add__(self, y: str or unicode or bytearray) -> unicode
    def __contains__(self, y: str or unicode or bytearray) -> bool
    def __getitem__(self, index: int or slice) -> unicode
    def __getslice__(self, i: Optional[int], j: Optional[int]) -> unicode
    def __len__(self) -> int
    def __mod__(self, y) -> unicode
    def __mul__(self, n: int) -> unicode
    def capitalize(self) -> unicode
    def center(self, width: int, ...) -> unicode
    def count(self, sub: str or unicode, ...) -> int
    def decode(self, ...) -> unicode
    def encode(self, ...) -> str
    def endswith(self, suffix: str or unicode or bytearray or tuple[str or unicode or bytearray, ...], ...) -> bool
    def expandtabs(self, ...) -> unicode
    def find(self, sub: str or unicode, ...) -> int
    def format(self, ...) -> unicode
    def index(self, sub: str or unicode, ...) -> int
    def isalnum(self) -> bool
    def isalpha(self) -> bool
    def isdecimal(self) -> bool
    def isdigit(self) -> bool
    def islower(self) -> bool
    def isnumeric(self) -> bool
    def isspace(self) -> bool
    def istitle(self) -> bool
    def isupper(self) -> bool
    def join(self, iterable: Iterable[basestring] or Iterable[nothing] or bytearray) -> unicode
    def ljust(self, width: int, ...) -> unicode
    def lower(self) -> unicode
    def lstrip(self, ...) -> unicode
    def partition(self, sep: str or unicode) -> tuple[unicode, unicode, unicode]
    def replace(self, old: str or unicode, new: str or unicode, ...) -> unicode
    def rfind(self, sub: str or unicode, ...) -> int
    def rindex(self, sub: str or unicode, ...) -> int
    def rjust(self, width: int, ...) -> unicode
    def rpartition(self, sep: str or unicode) -> tuple[unicode, unicode, unicode]
    def rsplit(self, ...) -> list[unicode]
    def rstrip(self, ...) -> unicode
    def split(self, ...) -> list[unicode]
    def splitlines(self, ...) -> list[unicode]
    def startswith(self, prefix: str or unicode or tuple[str or unicode, ...], ...) -> bool
    def strip(self, ...) -> unicode
    def swapcase(self) -> unicode
    def title(self) -> unicode
    def translate(self, table) -> unicode
    def upper(self) -> unicode
    def zfill(self, width: int) -> unicode

class bytearray(Sequence[int]):
    def __init__(self, iterable_of_ints) -> NoneType
    def __init__(self) -> NoneType
    def __init__(self, source: unicode, encoding: str or unicode, errors: str or unicode = ...) -> NoneType
    def __add__(self, y: str or bytearray) -> bytearray
    def __alloc__(self) -> int
    def __contains__(self, y: str or int or bytearray) -> bool
    def __delitem__(self, y: int) -> NoneType
    def __getitem__(self, index: int) -> int
    def __iter__(self) -> bytearray_iterator
    def __len__(self) -> int
    def __mul__(self, n: int) -> bytearray
    def append(self, int: str or int) -> NoneType
    def capitalize(self) -> bytearray
    def center(self, width: int, ...) -> bytearray
    def count(self, sub: str or bytearray, ...) -> int
    def decode(self, ...) -> unicode
    def endswith(self, suffix: str or unicode or bytearray or tuple[str or unicode or bytearray, ...], ...) -> bool
    def expandtabs(self, ...) -> bytearray
    def extend(self, iterable_int) -> NoneType
    def find(self, sub: str or bytearray, ...) -> int
    def fromhex(self, string: str or unicode or bytearray) -> bytearray
    def index(self, sub: str or bytearray, ...) -> int
    def insert(self, index: int, int: str or int) -> NoneType
    def isalnum(self) -> bool
    def isalpha(self) -> bool
    def isdigit(self) -> bool
    def islower(self) -> bool
    def isspace(self) -> bool
    def istitle(self) -> bool
    def isupper(self) -> bool
    def join(self, iterable: Iterable[nothing or str or bytearray]) -> bytearray
    def ljust(self, width: int, ...) -> bytearray
    def lower(self) -> bytearray
    def lstrip(self, ...) -> bytearray
    def partition(self, sep: str or int or bytearray or iterator) -> tuple[bytearray, bytearray, bytearray]
    def pop(self, ...) -> int
    def remove(self, int: str or int) -> NoneType
    def replace(self, old: str or bytearray, new: str or bytearray, ...) -> bytearray
    def reverse(self) -> NoneType
    def rfind(self, sub: str or bytearray, ...) -> int
    def rindex(self, sub: str or bytearray, ...) -> int
    def rjust(self, width: int, ...) -> bytearray
    def rpartition(self, sep: str or int or bytearray or iterator) -> tuple[bytearray, bytearray, bytearray]
    def rsplit(self, sep: str or bytearray, ...) -> list[bytearray]
    def rsplit(self) -> list[bytearray]
    def rstrip(self, ...) -> bytearray
    def split(self, ...) -> list[bytearray]
    def splitlines(self, ...) -> list[bytearray]
    def startswith(self, prefix: str or unicode or bytearray or tuple[str or unicode or bytearray, ...], ...) -> bool
    def strip(self, ...) -> bytearray
    def swapcase(self) -> bytearray
    def title(self) -> bytearray
    def upper(self) -> bytearray
    def zfill(self, width: int) -> bytearray

class bytearray_iterator(Iterator[int]):
    def __iter__(self) -> bytearray_iterator
    def next(self) -> int

class `dictionary-keyiterator`(Iterator[_T]):
    def __iter__(self) -> `dictionary-keyiterator`[_T]
    def next(self) -> _T

class `dictionary-valueiterator`(Iterator[_T]):
    def __iter__(self) -> `dictionary-valueiterator`[_T]
    def next(self) -> _T

class `dictionary-itemiterator`(Iterator[tuple[_K, _V]]):
    def __iter__(self) -> `dictionary-itemiterator`[_K, _V]
    def next(self) -> tuple[_K, _V]

class dict_keys(Iterator[_T]):
    def __contains__(self, y) -> bool
    def __iter__(self) -> `dictionary-keyiterator`[_T]
    def __len__(self) -> int
    def __and__(self, y: Iterable) -> set[_T]
    def __sub__(self, y: Iterable) -> set[_T]
    def __or__(self, y: Iterable[_T2]) -> set[_T or _T2]
    def __xor__(self, y: Iterable[_T2]) -> set[_T or _T2]

class dict_values(Iterator[_T]):
    def __iter__(self) -> `dictionary-valueiterator`[_T]
    def __len__(self) -> int

class dict_items(Generic[_K, _V], object):
    def __and__(self, y: set or dict_items) -> set[tuple[_K, _V]]
    def __or__(self, y: set or dict_items[_K2, _V2]) -> set[tuple[_K or _K2, _V or _V2]]
    def __xor__(self, y: set or dict_items[_K2, _V2]) -> set[tuple[_K or _K2, _V or _V2]]
    def __sub__(self, y: set or dict_items[_K2, _V2]) -> set[tuple[_K, _V]]
    def __contains__(self, y) -> bool
    def __iter__(self) -> `dictionary-itemiterator`[_K,_V]
    def __len__(self) -> int

class dict(Dict[_K, _V]):
    def __init__(self) -> NoneType:
        self := dict[nothing, nothing]
    def __init__(self, list: list[nothing]) -> NoneType:
        self := dict[nothing, nothing]
    def __init__(self, mapping: Mapping[_K2, _V2]) -> NoneType:
        self := dict[_K2, _V2]
    def __init__(self, iterable: Iterable[tuple[_K2, _V2]]) -> NoneType:
        self := dict[_K2, _V2]
    def __init__(self, ...) -> NoneType:
        self := dict[?, ?]
    def __delitem__(self, y: _K) -> NoneType
    def __iter__(self) -> `dictionary-keyiterator`[_K]
    def __len__(self) -> int
    def __setitem__(self, i: _K2, y: _V2) -> NoneType:
      self := dict[_K or _K2, _V or _V2]
    def clear(self) -> NoneType:
        self := dict[nothing, nothing]
    def copy(self) -> dict[_K, _V]
    @staticmethod
    def fromkeys(keys: Iterable[_K]) -> Dict[_K, NoneType]
    @staticmethod
    def fromkeys(keys: Iterable[_K], value: _V) -> Dict[_K, _V]
    def has_key(self, k) -> bool
    def iteritems(self) -> `dictionary-itemiterator`[_K,_V]
    def iterkeys(self) -> `dictionary-keyiterator`[_K]
    def itervalues(self) -> `dictionary-valueiterator`[_V]
    def pop(self, k) -> _V
    def pop(self, k, d: _V2) -> _V or _V2
    def setdefault(self, k: _K2) -> _V or NoneType:
        self := dict[_K or _K2, _V or NoneType]
    def setdefault(self, k: _K2, v: _V2) -> _V or _V2:
        self := dict[_K or _K2, _V or _V2]
    def update(self, other: dict[_K2, _V2]):
        self := dict[_K or _K2, _V or _V2]
    # TODO(kramm): Better definition:
    # def update(self, **kwargs: _V2):
    #     self := dict[_K or str, _V or _V2]
    def update(self, **kwargs):
        self := dict[_K or str, ?]
    def update(self, E, ...) -> NoneType:
        self := dict[?, ?]
    def update(self) -> NoneType
    def viewitems(self) -> dict_items[_K,_V]
    def viewkeys(self) -> dict_keys[_K]
    def viewvalues(self) -> dict_values[_V]

class listiterator(Iterator[_T]):
    def __iter__(self) -> listiterator[_T]
    def next(self) -> _T

class enumerate(Iterator[_T]):
    def __init__(self, iterable: Iterable[_T2], start: int = ...) -> NoneType:
      self := enumerate[_T2]
    def __iter__(self) -> enumerate[_T]  # enumerate.__iter__() returns itself
    def next(self) -> tuple[int, _T]

class listreverseiterator(Iterator[_T]):
    def __iter__(self) -> listreverseiterator[_T]
    def next(self) -> _T

class list(List[_T]):
    def __init__(self) -> NoneType:
        self := list[nothing]
    def __init__(self, iterable: Iterable[_T2]) -> NoneType:
        self := list[_T2]
    def __add__(self, y: list[_T2]) -> list[_T or _T2]
    def __contains__(self, y) -> bool
    def __delitem__(self, y: int or slice) -> NoneType
    def __delslice__(self, i: int, j: int) -> NoneType
    def __getitem__(self, index: int) -> _T
    def __getitem__(self, index: slice) -> list[_T]
    def __getslice__(self, i: Optional[int], j: Optional[int]) -> list[_T]
    def __iadd__(self, y: Iterable[_T2]) -> list[_T or _T2]
    def __iter__(self) -> listiterator[_T]
    def __len__(self) -> int
    def __mul__(self, n: int) -> list[_T]
    def __reversed__(self) -> listreverseiterator[_T]
    def __setitem__(self, i: int, y: _T2) -> NoneType:
      self := list[_T or _T2]
    def __setitem__(self, i: slice, y) -> NoneType:
      self := list[?]
    def __setslice__(self, i: int, j: int, y) -> NoneType
    def append(self, object: _T2) -> NoneType:
      self := list[_T or _T2]
    def extend(self, i: Iterable[_T2]) -> NoneType:
      self := list[_T or _T2]
    def extend(self, i: ?) -> NoneType:
      self := list[?]
    def count(self, value: _T) -> int
    def index(self, value, ...) -> int
    def insert(self, index: int, object: _T2) -> NoneType:
      self := list[_T or _T2]
    def pop(self) -> _T
    def pop(self, i: int) -> _T
    def remove(self, value: _T) -> NoneType
    def reverse(self) -> NoneType
    def sort(self, ...) -> NoneType

# "reversed" is a type, see PyReversed_Type in Objects/enumobject.c
class reversed(Iterator[_T]):
    def __init__(self, sequence: Reversible[_T2]) -> NoneType:
      self := reversed[_T2]
    def __iter__(self) -> reversed
    def next(self) -> _T

class tuple(Tuple[_T]):
    def __init__(self) -> NoneType:
      self := tuple[nothing, ...]
    def __init__(self, p0: Iterable[_T2]) -> NoneType:
      self := tuple[_T2, ...]
    def __add__(self, y: tuple[_T2, ...]) -> tuple[_T or _T2, ...]
    def __contains__(self, y) -> bool
    def __getitem__(self, index: int) -> _T
    def __getitem__(self, index: slice) -> tuple[_T, ...]
    def __getslice__(self, i: Optional[int], j: Optional[int]) -> tuple[_T, ...]
    def __iter__(self) -> tupleiterator[_T]
    def __len__(self) -> int
    def __mul__(self, n: int) -> tuple[_T, ...]
    def count(self, value: _T) -> int
    def index(self, value, ...) -> int

class tupleiterator(Iterator[_T]):
    def __iter__(self) -> tupleiterator[_T]
    def next(self) -> _T

class set(Set[_T]):
    def __init__(self) -> NoneType:
        self := set[nothing]
    def __init__(self, iterable: Iterable[_T2]) -> NoneType:
        self := set[_T2]
    def __and__(self, y: Iterable) -> set[_T]
    def __contains__(self, y) -> bool
    def __iter__(self) -> setiterator[_T]
    def __len__(self) -> int
    def __or__(self, y: Iterable[_T2]) -> set[_T or _T2]
    def __sub__(self, y: Iterable) -> set[_T]
    def __xor__(self, y: Iterable[_T2]) -> set[_T or _T2]
    def clear(self) -> NoneType:
        self := set[nothing]
    def copy(self) -> set[_T]
    def discard(self, y) -> NoneType
    def difference_update(self, ...) -> NoneType
    def symmetric_difference_update(self, ...) -> NoneType
    def intersection_update(self, ...) -> NoneType
    def isdisjoint(self, y: Iterable) -> bool
    def issubset(self, y: Iterable) -> bool
    def issuperset(self, y: Iterable) -> bool
    def pop(self) -> _T
    def remove(self, x) -> None
    def update(self, ...) -> NoneType:
        self := set[?]
    def add(self, y: _T2) -> NoneType:
        self := set[_T or _T2]
    # Even though these look like instance methods (i.e., you can call
    # {1}.union(x)), they're actually static methods. (Which will accept a
    # variable number of arguments, the first of which can e.g. be self.)
    @staticmethod
    def union(...) -> set[?]
    @staticmethod
    def intersection(...) -> set[?]
    @staticmethod
    def difference(...) -> set[?]
    @staticmethod
    def symmetric_difference(Iterable) -> set[?]

class frozenset(FrozenSet[_T]):
    def __init__(self) -> NoneType:
        self := frozenset[nothing]
    def __init__(self, x: Iterable[_T2]) -> NoneType:
        self := frozenset[_T2]
    def __and__(self, y: AbstractSet) -> frozenset[_T]
    def __contains__(self, y) -> bool
    def __iter__(self) -> setiterator[_T]
    def __len__(self) -> int
    def __or__(self, y: AbstractSet[_T2]) -> frozenset[_T or _T2]
    def __sub__(self, y: AbstractSet[_T2]) -> frozenset[_T]
    def __xor__(self, y: AbstractSet[_T2]) -> frozenset[_T or _T2]
    def copy(self, ...) -> frozenset[_T]
    def isdisjoint(self, y: AbstractSet[_T2]) -> bool
    def issubset(self, y: AbstractSet[_T2]) -> bool
    def issuperset(self, y: AbstractSet[_T2]) -> bool
    @staticmethod
    def union(...) -> frozenset[?]
    @staticmethod
    def intersection(...) -> frozenset[?]
    @staticmethod
    def difference(...) -> frozenset[?]

class setiterator(Iterator[_T]):
    def __iter__(self) -> setiterator[_T]
    def next(self) -> _T

class bool(int, SupportsInt, SupportsFloat):
    def __init__(self, x) -> NoneType
    def __init__(self) -> NoneType
    def __abs__(self) -> int
    def __add__(self, y: int or bool) -> int
    def __and__(self, y: bool) -> bool
    def __and__(self, y: int) -> int
    def __coerce__(self, y: int) -> Tuple[bool, int]
    def __coerce__(self, y: bool) -> Tuple[bool, bool]
    def __div__(self, y: int or bool) -> int
    def __divmod__(self, y: int or bool) -> Tuple[int, int]
    def __float__(self) -> float
    def __floordiv__(self, y: int or bool) -> int
    def __hex__(self) -> str
    def __index__(self) -> int
    def __int__(self) -> int
    def __invert__(self) -> int
    def __long__(self) -> int
    def __lshift__(self, y: int) -> int
    def __mod__(self, y: int) -> int
    def __mul__(self, y: int) -> int
    def __neg__(self) -> int
    def __nonzero__(self) -> bool
    def __oct__(self) -> str
    def __or__(self, y: bool) -> bool
    def __or__(self, y: int) -> int
    def __pos__(self) -> int
    def __pow__(self, y: bool) -> int
    def __pow__(self, y: int) -> int or float  # True ** -2 == 0.5
    def __pow__(self, y: int, modulo: int or bool) -> int
    def __rshift__(self, y: int) -> int
    def __sub__(self, y: int) -> int
    def __truediv__(self, y: int) -> float
    def __trunc__(self, ...) -> int
    def __xor__(self, y: bool) -> bool
    def __xor__(self, y: int) -> int
    def bit_length(self) -> int
    def conjugate(self, ...) -> int

class int(SupportsInt, SupportsFloat, SupportsAbs):
    denominator = ...  # type: int
    numerator = ... # type: int
    real = ... # type: int
    imag = ... # type: int
    def __init__(self) -> NoneType
    def __init__(self, x: int or float or str or unicode or SupportsInt) -> NoneType
    def __init__(self, x: str or unicode, base: int) -> NoneType
    def __add__(self, y: int) -> int
    def __add__(self, y: float) -> float
    def __add__(self, y: complex) -> complex
    def __and__(self, y: int) -> int
    def __and__(self, y: float) -> float
    def __and__(self, y: complex) -> complex
    def __div__(self, y: int) -> int
    def __div__(self, y: float) -> float
    def __div__(self, y: complex) -> complex
    def __divmod__(self, y: int) -> Tuple[int, int]
    def __divmod__(self, y: float) -> Tuple[float, float]
    def __divmod__(self, y: complex) -> Tuple[complex, complex]
    def __floordiv__(self, y: int) -> int
    def __floordiv__(self, y: float) -> float
    def __floordiv__(self, y: complex) -> complex
    def __mod__(self, y: int) -> int
    def __mod__(self, y: float) -> float
    def __mod__(self, y: complex) -> complex
    def __mul__(self, y: int) -> int
    def __mul__(self, y: float) -> float
    def __mul__(self, y: complex) -> complex
    def __mul__(self, n: str) -> str
    def __mul__(self, n: list[_T]) -> list[_T]
    def __mul__(self, n: tuple[_T, ...]) -> tuple[_T, ...]
    def __mul__(self, n: buffer) -> str
    def __mul__(self, n: bytearray) -> bytearray
    def __pow__(self, y: int, modulo: int) -> int
    def __pow__(self, y: int) -> int or float  # 1 ** -2 == 0.5
    def __pow__(self, y: float) -> float
    def __pow__(self, y: complex) -> complex
    def __rshift__(self, y: int) -> int
    def __sub__(self, y: int) -> int
    def __sub__(self, y: float) -> float
    def __sub__(self, y: complex) -> complex
    def __truediv__(self, y: int or float) -> float
    def __truediv__(self, y: complex) -> complex
    def __abs__(self) -> int
    def __coerce__(self, y: int) -> Tuple[int, int]
    def __float__(self) -> float
    def __hex__(self) -> str
    def __index__(self) -> int
    def __int__(self) -> int
    def __invert__(self) -> int
    def __long__(self) -> int
    def __lshift__(self, y: int) -> int
    def __neg__(self) -> int
    def __nonzero__(self) -> bool
    def __oct__(self) -> str
    def __or__(self, y: int) -> int
    def __pos__(self) -> int
    def __trunc__(self, ...) -> int
    def __xor__(self, y: int) -> int
    def bit_length(self) -> int
    def conjugate(self) -> int

long = int

class float(SupportsInt, SupportsFloat, SupportsAbs):
    real = ... # type: float
    imag = ... # type: float
    def __init__(self, x: int or float or str or unicode or SupportsFloat) -> NoneType
    def __init__(self) -> NoneType
    def __abs__(self) -> float
    def __add__(self, y: int or float) -> float
    def __add__(self, y: complex) -> complex
    def __coerce__(self, y: int or float) -> Tuple[float, float or int]
    def __div__(self, y: int or float) -> float
    def __div__(self, y: complex) -> complex
    def __divmod__(self, y: int or float) -> Tuple[float, float]
    def __divmod__(self, y: complex) -> Tuple[complex, complex]
    def __float__(self) -> float
    def __floordiv__(self, y: int or float) -> float
    def __floordiv__(self, y: complex) -> complex
    def __hex__(self) -> str
    def __index__(self) -> int
    def __int__(self) -> int
    def __invert__(self) -> int
    def __long__(self) -> int
    def __mod__(self, y: int or float) -> float
    def __mod__(self, y: complex) -> complex
    def __mul__(self, y: int or float) -> float
    def __mul__(self, y: complex) -> complex
    def __neg__(self) -> float
    def __nonzero__(self) -> bool
    def __oct__(self) -> str
    def __pos__(self) -> float
    def __pow__(self, y: int or float) -> float
    def __pow__(self, y: complex) -> complex
    def __sub__(self, y: int or float) -> float
    def __sub__(self, y: complex) -> complex
    def __truediv__(self, y: int or float) -> float
    def __truediv__(self, y: complex) -> complex
    def __trunc__(self, ...) -> int
    def conjugate(self) -> float
    def as_integer_ratio(self) -> tuple[int, int]
    def fromhex(self, string: str or unicode or bytearray) -> float
    def hex(self) -> str
    def is_integer(self) -> bool

class complex(SupportsAbs):
    real = ... # type: float
    imag = ... # type: float
    def __init__(self, real: int or float or complex or str or unicode or typing.SupportsComplex, ...) -> NoneType
    def __init__(self) -> NoneType
    def __abs__(self) -> float
    def __add__(self, y: int or float or complex) -> complex
    def __coerce__(self, y: int or float or complex) -> Tuple[complex, complex]
    def __div__(self, y: int or float or complex) -> complex
    def __divmod__(self, y: int or float or complex) -> Tuple[complex, complex]
    def __floordiv__(self, y: int or float or complex) -> complex
    def __mod__(self, y: int or float or complex) -> complex
    def __mul__(self, y: int or float or complex) -> complex
    def __neg__(self) -> complex
    def __nonzero__(self) -> bool
    def __pos__(self) -> complex
    def __pow__(self, y: int or float or complex) -> complex
    def __sub__(self, y: int or float or complex) -> complex
    def __truediv__(self, y: int or float or complex) -> complex
    def conjugate(self) -> complex

class buffer(Sized, Iterable[int]):
    def __init__(self, object: str or unicode or bytearray or buffer, ...) -> NoneType
    def __add__(self, y: str or unicode or bytearray or buffer) -> str
    def __getitem__(self, index: int) -> str
    def __getslice__(self, i: Optional[int], j: Optional[int]) -> str
    def __len__(self) -> int
    def __mul__(self, n: int) -> str

class file(BinaryIO):
    def __init__(self, name: str, ...) -> NoneType
    def __iter__(self) -> file
    def __enter__(self) -> file
    def __exit__(self, ...) -> NoneType
    def close(self) -> NoneType
    def fileno(self) -> int
    def flush(self) -> NoneType
    def isatty(self) -> bool
    def next(self) -> str
    def read(self, ...) -> str
    def readline(self, ...) -> str
    def readlines(self, ...) -> list[str]
    def seek(self, offset: int or float, ...) -> NoneType
    def tell(self) -> int
    def truncate(self, ...) -> NoneType
    def write(self, str: str or unicode or bytearray) -> NoneType
    def writelines(self, sequence_of_strings) -> NoneType
    def xreadlines(self) -> file

class generator(Generator[_T, _T2, _V]):
    def __iter__(self) -> generator[_T, _T2, _V]
    def send(self, value: _T2) -> _T
    def close(self) -> NoneType
    def next(self) -> _T

class instancemethod(object):
    def __init__(self, function: Callable or instancemethod, instance, cls) -> NoneType
    def __get__(self, obj, ...) -> instancemethod

class module(object):
    __file__ = ...  # type: str
    __name__ = ...  # type: str
    __doc__ = ...  # type: str or unicode
    __package__ = ...  # type: Optional[str]
    def __init__(self, name: str or bytearray, doc = ...) -> NoneType
    def __getattr__(self, name) -> ?  # modules can contain anything

class slice(object):
    start = ...  # type: Optional[int]
    stop = ...  # type: Optional[int]
    step = ...  # type: Optional[int]
    def __init__(self, stop, ...) -> NoneType
    def indices(self, len: int) -> tuple[int, int, int]

class memoryview(object):
    def __init__(self, object: str or bytearray or memoryview) -> NoneType
    def __getitem__(self, index: int) -> str
    def __len__(self) -> int
    def tobytes(self, ...) -> str
    def tolist(self, ...) -> list[int]

class type(Callable, Type[_T]):
    __name__ = ...  # type: str
    __module__ = ...  # type: str
    __bases__ = ...  # type: Tuple[type, ...]
    __base__ = ...  # type: Optional[type]
    __dictoffset__ = ...  # type: int
    __itemsize__ = ...  # type: int
    def __new__(cls: Type[type], object: _T) -> Type[_T]
    # The return type in the below two definitions is used only when abstract.py
    # isn't able to build a class from the arguments.
    def __new__(cls: Type[type], name: str, bases: tuple[type, ...], dict: Dict[str, ?]) -> type
    def __init__(self, object) -> None: ...
    def __init__(self, name, bases, dict) -> None: ...
    def __subclasses__(self) -> List[type]: ...
    def __instancecheck__(self, object) -> bool: ...
    def __subclasscheck__(self, cls) -> bool: ...
    def mro(self) -> List[type]: ...

class iterator(Iterator[_T]):
    def __iter__(self) -> iterator[_T]
    def next(self) -> _T

class `callable-iterator`(Iterator[_T]):
    def __iter__(self) -> `callable-iterator`[_T]
    def next(self) -> _T

# Usually the class argument to super() already inherits from object. So to
# avoid confusion, super() inherits from nothing.
class super(nothing):
    def __init__(self, ...) -> NoneType
    def __get__(self, obj, ...) -> super
    def __set__(self, obj, value) -> super
    def __new__(cls: Type[super], ...) -> super

class xrange(Sequence[int]):
    def __init__(self, stop: int, ...) -> NoneType
    def __getitem__(self, index: int) -> int
    def __iter__(self) -> Iterator[int]
    def __len__(self) -> int
    def __reversed__(self, ...) -> Iterator[int]

# From Python/objects/capsule.c. Used e.g. by datetime.datetime_CAPI
class PyCapsule(object):
    pass

# types.CodeType, a.k.a., [type 'code']
class code(object):
    pass

class ArithmeticError(StandardError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class AssertionError(StandardError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class AttributeError(StandardError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class BaseException(object):
    message = ...  # type: str
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class BufferError(StandardError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class BytesWarning(Warning):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class DeprecationWarning(Warning):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class EOFError(StandardError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class EnvironmentError(StandardError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class Exception(BaseException):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class FloatingPointError(ArithmeticError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class FutureWarning(Warning):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class GeneratorExit(BaseException):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class IOError(EnvironmentError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class ImportError(StandardError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class ImportWarning(Warning):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class IndentationError(SyntaxError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class IndexError(LookupError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class KeyError(LookupError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class KeyboardInterrupt(BaseException):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class LookupError(StandardError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class MemoryError(StandardError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class NameError(StandardError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class NotImplementedError(RuntimeError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class OSError(EnvironmentError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class OverflowError(ArithmeticError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class PendingDeprecationWarning(Warning):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class ReferenceError(StandardError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class RuntimeError(StandardError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class RuntimeWarning(Warning):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class StandardError(Exception):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class StopIteration(Exception):
    def __init__(self, p0) -> NoneType
    def __init__(self) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class SyntaxError(StandardError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class SyntaxWarning(Warning):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class SystemError(StandardError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class SystemExit(BaseException):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class TabError(IndentationError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class TypeError(StandardError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class UnboundLocalError(NameError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class UnicodeError(ValueError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class UnicodeDecodeError(UnicodeError): ...

class UnicodeEncodeError(UnicodeError): ...

class UnicodeTranslateError(UnicodeError): ...

class UnicodeWarning(Warning):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class UserWarning(Warning):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class ValueError(StandardError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class Warning(Exception):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode

class ZeroDivisionError(ArithmeticError):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple
    def __unicode__(self, ...) -> unicode
