# Special-cased by the parser: TypeVar, Any, NamedTuple, Optional, Union
__all__ = ...  # type: List[str]
AnyStr = TypeVar('AnyStr', str, unicode)
ARGS = TypeVar('ARGS')
RET = TypeVar('RET')
# "T", "K", and "V" are hardcoded in abstract.py
T = TypeVar('T')
K = TypeVar('K')
V = TypeVar('V')
K2 = TypeVar('K2')
V2 = TypeVar('V2')
T2 = TypeVar('T2')


# This function does not exist in typing.py. It is here for documentation
# purposes and to make it easier for pytype to type-check arguments to TypeVar.
def _typevar_new(name: str, *constraints: type, bound: type=None, covariant: bool=False, contravariant: bool=False): ...


class Callable(Generic[ARGS, RET]):
  def __call__(self, ...) -> ?


class Generic(object): ...


class SupportsInt(object):
  def __int__(self) -> int: ...


class SupportsFloat(object):
  def __float__(self) -> float: ...


class SupportsComplex(object):
  def __complex__(self) -> complex: ...


class SupportsAbs(Generic[T]):
  def __abs__(self) -> T: ...


class SupportsRound(Generic[T]):
  def __round__(self, ndigits: int = ...) -> T: ...


class Reversible(Generic[T]):
  def __reversed__(self) -> Iterator[T]: ...


class Iterator(Iterable[T]):
  def next(self) -> T: ...


class Iterable(Generic[T]):
  def __iter__(self) -> Iterator[T]


class Sized(object):
  def __len__(self) -> int: ...


class Hashable(object):
  def __hash__(self) -> int: ...


class Container(Generic[T]):
  def __contains__(self, x) -> bool: ...


class Sequence(Sized, Iterable[T], Container[T], Reversible[T]):
  def __getitem__(self, i: int) -> T: ...
  def __getitem__(self, s: slice) -> Sequence[T]: ...
  def __getslice__(self, ...) -> Sequence[T]: ...
  def index(self, x) -> int: ...
  def count(self, x) -> int: ...
  def __contains__(self, x) -> bool: ...
  def __iter__(self) -> Iterator[T]: ...
  def __reversed__(self) -> Iterator[T]: ...


class Tuple(Sequence[T]): ...


class MutableSequence(Sequence[T]):
  def __setitem__(self, i: int, v: T2) -> None:
    self := MutableSequence[T or T2]
  def __setitem__(self, i: slice, v: Iterable[T2]) -> None:
    self := MutableSequence[T or T2]
  def __setslice__(self, i, j, s: Iterable[T2]) -> None:
    self := MutableSequence[T or T2]
  def __delitem__(self, i: Union[int, slice]) -> None: ...
  def __add__(self, x: Iterable[T2]) -> MutableSequence[T or T2]: ...
  def append(self, v: T2) -> None:
    self := MutableSequence[T or T2]
  def extend(self, iterable: Iterable[T2]) -> None:
    self := MutableSequence[T or T2]
  def insert(self, i: int, v: T2) -> None:
    self := MutableSequence[T or T2]
  def reverse(self) -> None: ...
  def pop(self, index: int = ...) -> T: ...
  def remove(self, value: T) -> None: ...


class List(MutableSequence[T]): ...


class IO(Iterator[AnyStr]):
  name = ...  # type: str
  mode = ...  # type: str
  closed = ...  # type: bool
  def __enter__(self) -> IO[AnyStr]: ...
  def __exit__(self, t, value, traceback) -> bool: ...
  def __iter__(self) -> Iterator[AnyStr]: ...
  def next(self) -> AnyStr: ...
  def close(self) -> None: ...
  def fileno(self) -> int: ...
  def flush(self) -> None: ...
  def isatty(self) -> bool: ...
  def read(self, n: int = ...) -> AnyStr: ...
  def readable(self) -> bool: ...
  def readline(self, limit: int = ...) -> AnyStr: ...
  def readlines(self, hint: int = ...) -> list[AnyStr]: ...
  def seek(self, offset: int, whence: int = ...) -> None: ...
  def seekable(self) -> bool: ...
  def tell(self) -> int: ...
  def truncate(self, size: int = ...) -> Optional[int]: ...
  def writable(self) -> bool: ...
  def write(self, s: AnyStr) -> None: ...
  def writelines(self, lines: Iterable[AnyStr]) -> None: ...


class BinaryIO(IO[str]): ...


class TextIO(IO[unicode]): ...


class Mapping(Sized, Iterable[K], Container[K], Generic[K, V]):
  def copy(self) -> Mapping[K, V]: ...
  def __contains__(self, o) -> bool: ...
  def __getitem__(self, key: K) -> V: ...
  def get(self, k) -> V or NoneType
  def get(self, k, d: V2) -> V or V2
  # TODO(kramm): The below should be "AbstractSet", not "list"
  def items(self) -> list[Tuple[K, V]]: ...
  def keys(self) -> list[K]: ...
  def values(self) -> list[V]: ...
  def iteritems(self) -> list[Tuple[K, V]]: ...
  def iterkeys(self) -> list[K]: ...
  def itervalues(self) -> list[V]: ...
  # TODO(kramm): The below should be "ItemsView", "KeysView" and "ValuesView"
  def viewitems(self) -> list[Tuple[K, V]]: ...
  def viewkeys(self) -> list[K]: ...
  def viewvalues(self) -> list[V]: ...


class MutableMapping(Mapping[K, V]):
  def copy(self) -> MutableMapping[K, V]: ...
  def __setitem__(self, k: K2, v: V2) -> None:
    self := MutableMapping[K or K2, V or V2]
  def __delitem__(self, k) -> None: ...
  def clear(self) -> None:
    self := MutableMapping[nothing, nothing]
  def pop(self, k, default: V2 = ...) -> V or V2: ...
  def popitem(self) -> Tuple[K, V]: ...
  def setdefault(self, k: K2, default: V2 = ...) -> V or V2:
    self := MutableMapping[K or K2, V or V2]
  def update(self, m: Mapping[K2, V2]) -> None:
    self := MutableMapping[K or K2, V or V2]
  def update(self, m: Iterable[Tuple[T, ...]]) -> None:
    self := MutableMapping[K or T, V or T]


class DefaultDict(MutableMapping[K, V]): ...


class Dict(MutableMapping[K, V]): ...


class AbstractSet(Iterable[T], Container[T]):
  def __contains__(self, x) -> bool: ...
  def __and__(self, s: AbstractSet[?]) -> AbstractSet[T]: ...
  def __or__(self, s: AbstractSet[T2]) -> AbstractSet[T or T2]: ...
  def __sub__(self, s: AbstractSet[?]) -> AbstractSet[T]: ...
  def __xor__(self, s: AbstractSet[T2]) -> AbstractSet[T or T2]: ...
  def isdisjoint(self, s: Iterable) -> bool: ...


class FrozenSet(AbstractSet[T]): ...


class MutableSet(AbstractSet[T]):
  def add(self, x: T2) -> None:
    self := MutableSet[T or T2]
  def discard(self, x) -> None: ...
  def clear(self) -> None:
    self := MutableSet[nothing]
  def pop(self) -> T: ...
  def remove(self, element: T) -> None: ...
  def __or__(self, s: AbstractSet[T2]) -> MutableSet[T or T2]: ...
  def __and__(self, s: AbstractSet[?]) -> MutableSet[T]: ...
  def __xor__(self, s: AbstractSet[T2]) -> MutableSet[T or T2]: ...


class Set(MutableSet[T]): ...


# T is the yield type, T2 the send type, V the return type.
class Generator(Iterator[T], Generic[T, T2, V]):
  def next(self) -> T: ...
  def send(self, value: T2) -> T: ...
  def throw(self, typ: BaseException, val = ..., tb = ...) -> None: ...
  def close(self) -> None: ...


class Type(Generic[T]): ...


class Pattern(Generic[AnyStr]):
  flags = ...  # type: int
  groups = ...  # type: int
  groupindex = ...  # type: Dict[str, int]
  pattern = ...  # type: AnyStr
  def search(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Match[AnyStr]: ...
  def match(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Match[AnyStr]: ...
  def split(self, string: AnyStr, maxsplit: int = ...) -> List[AnyStr]
  def findall(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> List[?]: ...
  def finditer(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Iterator[Match[AnyStr]]
  def sub(self, repl: AnyStr or Callable, string: AnyStr, count: int = ...) -> AnyStr: ...
  def subn(self, repl: AnyStr or Callable, string: AnyStr, count: int = ...) -> Tuple[AnyStr, int]


class Match(Generic[AnyStr]):
  pos = ...  # type: int
  endpos = ...  # type: int
  lastindex = ...  # type: int
  lastgroup = ...  # type: str or None
  re = ...  # type: Pattern[AnyStr]
  string = ...  # type: AnyStr
  def expand(self, template: AnyStr) -> AnyStr: ...
  def group(self) -> AnyStr: ...
  def group(self, group1: str or int) -> AnyStr: ...
  def group(self, group1: str or int, group2: str or int, *groups) -> Tuple[AnyStr, ...]: ...
  def groups(self, default: AnyStr = ...) -> Tuple[AnyStr, ...]: ...
  def groupdict(self, default: AnyStr = ...) -> Dict[str, AnyStr]: ...
  def start(self, group: int or str = ...) -> int: ...
  def end(self, group: int or str = ...) -> int: ...
  def span(self, group: int or str = ...) -> Tuple[int, int]: ...


# Used to mark attributes as class-level, as opposed to instance-level.
# TODO(kramm): Add support for this to pytype.
class ClassVar(Generic[T]): ...


# TODO(kramm): register with str and bytearray
class ByteString(Sequence[int]): ...


class MappingView(Sized, Iterable[T]): ...
class KeysView(MappingView[T], AbstractSet[T]): ...
class ValuesView(MappingView[T]): ...
class ItemsView(MappingView[tuple], AbstractSet[tuple]): ...

def NewType(name, tp) -> type

Text = unicode

# TODO(kramm): def cast(typ: Type[T], val) -> T
def cast(typ, val) -> ?

def overload(func: T) -> T
def no_type_check(arg: T) -> T
def no_type_check_decorator(decorator) -> Callable
def get_type_hints(obj, ...) -> Optional[Dict[str, Any]]

# The following only exist in Python 3's typing.py, not in
# https://github.com/python/typeshed/blob/master/stdlib/2/typing.pyi
# TODO(kramm): Can we backport "Collection"?
# Awaitable,
# AsyncIterator,
# AsyncIterable,
# Coroutine,
# Collection,
# ContextManager,
# AsyncGenerator,

TYPE_CHECKING = ...  # type: bool
