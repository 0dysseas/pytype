# Special-cased by the parser: TypeVar, Any, NamedTuple
AnyStr = TypeVar('AnyStr', str, unicode)
ARGS = TypeVar('ARGS')
RET = TypeVar('RET')
T = TypeVar('T')
K = TypeVar('K')
V = TypeVar('V')

class Callable(Generic[ARGS, RET]):
  def __call__(self, ...) -> Any

class Generic(object): ...
class Iterator(Iterable[T]): ...

class Iterable(Generic[T]):
  @abstractmethod
  def __iter__(self) -> Iterator[T]

class Container(Generic[T]): ...
class Sized(object): ...  # same as in collections.abc
class Sequence(Sized, Iterable[T], Container[T], Reversible[T]): ...
class Tuple(Sequence[T]): ...
class MutableSequence(Sequence[T]): ...
class List(MutableSequence[T]): ...

class IO(Iterator[AnyStr]):
  @property
  def name(self) -> str: ...
  def __enter__(self) -> IO: ...
  def __exit__(self, t, value, traceback) -> bool: ...
  # Note that pytype simply throws away the @abstractmethod decorator.
  @abstractmethod
  def write(self, s: AnyStr) -> None
class BinaryIO(IO[str]): ...
class TextIO(IO[unicode]): ...

class Mapping(Sized, Iterable[K], Container[K], Generic[K, V]): ...
class MutableMapping(Mapping[K, V]): ...
class Dict(MutableMapping[K, V]): ...
class AbstractSet(Iterable[T]): ...
class FrozenSet(AbstractSet[T]): ...
class MutableSet(AbstractSet[T]): ...
class Set(MutableSet[T]): ...
class Reversible(Generic[T]): ...
class SupportsInt(object): ...
class SupportsFloat(object): ...
class SupportsAbs(Generic[T]): ...
class Optional(Generic[T]): ...
class Generator(Iterator[T]): ...
class Type(Generic[T]): ...

class Pattern(Generic[AnyStr]):
  flags = ...  # type: int
  groups = ...  # type: int
  groupindex = ...  # type: Dict[str, int]
  pattern = ...  # type: AnyStr
  def search(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Match[AnyStr]: ...
  def match(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Match[AnyStr]: ...
  def split(self, string: AnyStr, maxsplit: int = ...) -> List[AnyStr]
  def findall(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> List[Any]: ...
  def finditer(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Iterator[Match[AnyStr]]
  def sub(self, repl: AnyStr, string: AnyStr, count: int = ...) -> AnyStr: ...
  def subn(self, repl: AnyStr, string: AnyStr, count: int = ...) -> Tuple[AnyStr or int]

class Match(Generic[AnyStr]):
  pos = ...  # type: int
  endpos = ...  # type: int
  lastindex = ...  # type: int
  lastgroup = ...  # type: str or None
  re = ...  # type: Pattern[AnyStr]
  string = ...  # type: AnyStr
  def expand(self, template: AnyStr) -> AnyStr: ...
  def group(self) -> AnyStr: ...
  def group(self, group1: str or int) -> AnyStr: ...
  def group(self, group1: str or int, group2: str or int, *groups) -> Tuple[AnyStr]: ...
  def groups(self, default: AnyStr = ...) -> Tuple[AnyStr]: ...
  def groupdict(self, default: AnyStr = ...) -> Dict[str, AnyStr]: ...
  def start(self, group: int or str = ...) -> int: ...
  def end(self, group: int or str = ...) -> int: ...
  def span(self, group: int or str = ...) -> Tuple[int]: ...

# TODO(rechen): All of the types below this point are placeholder
# definitions from github.com/python/typing/blob/master/src/typing.py.
# They need to be fleshed out and tested.

class AsyncIterable(object): ...
class AsyncIterator(object): ...
class Awaitable(object): ...
class ByteString(object): ...
class DefaultDict(object): ...
class Final(object): ...
class Hashable(object): ...
class ItemsView(object): ...
class KeysView(object): ...
class MappingView(object): ...
class SupportsBytes(object): ...
class SupportsComplex(object): ...
class SupportsRound(object): ...
class Union(object): ...
class ValuesView(object): ...

def cast(typ, val) -> Any
def get_type_hints(obj, ...) -> Any
def NewType(name, tp) -> Any
def no_type_check(arg) -> Any
def no_type_check_decorator(decorator) -> Any
def overload(func) -> Any

Text = str
TYPE_CHECKING = ...  # type: bool
