# TODO(pludemann): The list of missing attributes and methods is probably
#                  incorrect and needs to be updated with automation.
# TODO(pludemann): Needs to be carefully audited - there are some known errors
#                  (which are marked with TODO) but not exhaustively
def convert(gr, raw_node) -> object
def generate_matches(patterns, nodes) -> generator
def type_repr(type_num) -> object
#
# To get the class/method info:
# for cls in (pytree.Base, pytree.BasePattern, pytree.Leaf, pytree.LeafPattern,
#             pytree.NegatedPattern, pytree.Node, pytree.NodePattern,
#             pytree.WildcardPattern):
#   for m in sorted(inspect.getmembers(cls)):  # optionally add param inspect.ismethod
#      print cls.__name__, m

class Base:
    # children = tuple     # TODO(pludemann): missing
    # parent = object      # TODO(pludemann): missing
    # type = object        # TODO(pludemannn): missing
    # was_changed = bool   # TODO(pludemann): missing
    # was_checked = bool   # TODO(pludemann): missing
    # next_sibling: property  # TODO(pludemann): missing
    # prev_sibling: property  # TODO(pludemann): missing
    # type_repr: property   # TODO(pludemann): missing
    # def __new__(self, *args, **kwds) -> Base  # TODO(pludemann) how to handle this?
    # TODO(pludemann): should the "raise NotImplemented" methods be added?
    #     _eq
    #     clone
    #     post_order
    #     pre_order
    #
    def __eq__(self, other) -> NotImplementedType or bool
    def __ne__(self, other) -> NotImplementedType or bool
    def __str__(self) -> str
    # def changed(self) -> NoneType  # TODO(pludemann): missing
    # def changed(self: Leaf or Node) -> NoneType  # TODO(pludemann): missing
    def depth(self) -> int
    def descend_to(self, indexes) -> Base
    def get_lineno(self) -> NoneType  # TODO(pludemann): def get_lineno(self) -> int
    # def get_prefix(self) -> ...  # TODO(pludemann): add?
    # def get_suffix(self) -> str  # TODO(pludemann): missing
    def label_nodes(self, indexes) -> NoneType
    def leaves(self) -> generator
    def remove(self) -> NoneType  # TODO(pludemann): def remove(self) -> int
    # def replace(self, new: list<object> or listiterator<object>) -> NoneType  # TODO(pludemann): missing
    def set_prefix(self, prefix) -> NoneType  # TODO(pludemann): shouldn't return list<object> or NoneType

class BasePattern:
    # content = None
    # name = None
    # type = None
    # type_repr: property
    #  __new__
    # def __repr__(self) -> str  # TODO(pludemann): missing
    # def type_repr ... property
    def generate_matches(self, nodes) -> generator
    def match(self: BasePattern or LeafPattern, node, results: dict<NoneType, object>) -> bool
    def match_seq(self, nodes, results: dict<NoneType, object>) -> bool
    def optimize(self) -> BasePattern

class Leaf:  # TODO(pludemann): should be class Leafe(Base):
    # Leaf ('_prefix', '')
    # Leaf ('children', ())
    # Leaf ('column', 0)
    # Leaf ('lineno', 0)
    # Leaf ('next_sibling', property)
    # Leaf ('parent', None)
    # Leaf ('prefix', property)
    # Leaf ('prev_sibling', property)
    # Leaf ('type', None)
    # Leaf ('type_repr', property)
    # Leaf ('was_changed', False)
    # Leaf ('was_checked', False)
    # ('__eq__', <unbound method Leaf.__eq__>)  inherited
    # ('__ne__', <unbound method Leaf.__ne__>)  inherited
    # ('__str__', <unbound method Leaf.__str__>)  inherited
    # ('changed', <unbound method Leaf.changed>)  inherited
    # ('depth', <unbound method Leaf.depth>)  inherited
    # ('descend_to', <unbound method Leaf.descend_to>)  inherited
    # ('get_lineno', <unbound method Leaf.get_lineno>)  inherited
    # ('get_prefix', <unbound method Leaf.get_prefix>)  inherited
    # ('get_suffix', <unbound method Leaf.get_suffix>)  inherited
    # ('label_nodes', <unbound method Leaf.label_nodes>)  inherited
    # ('remove', <unbound method Leaf.remove>)  inherited
    # ('replace', <unbound method Leaf.replace>)  inherited
    # ('set_prefix', <unbound method Leaf.set_prefix>)  inherited
    def __init__(self, type: float or int or long, value, context, prefix, fixers_applied: dict<slice, object>) -> NoneType
    def __init__(self, type: float or int or long, value, context) -> NoneType
    # def __repr__(self) -> str  # TODO(pludemann): missing
    # def __unicode__(self) -> ...  # TODO(pludemann)
    def _eq(self, other) -> bool
    def _prefix_getter(self) -> object  # TODO(pludemann): def _prefix_getter(self) -> buffer or str or unicode
    def _prefix_setter(self, prefix) -> NoneType
    def leaves(self) -> generator
    def post_order(self) -> generator
    def pre_order(self) -> generator
    # def _prefix_getter(self):  TODO(pludemann): missing
    # def _prefix_setter(self, prefix):  TODO(pludemann): missing
    # def append_child(self, child):  TODO(pludemann): missing
    # def clone(self):  TODO(pludemann): missing
    # def insert_child(self, i, child):  TODO(pludemann): missing
    # def set_child(self, i, child):  TODO(pludemann): missing

class LeafPattern:  # TODO(pludemann): class LeafPattern(BasePattern):
    # ('__init__', <unbound method LeafPattern.__init__>)
    # ('__repr__', <unbound method LeafPattern.__repr__>)
    # ('_submatch', <unbound method LeafPattern._submatch>)
    # ('generate_matches', <unbound method LeafPattern.generate_matches>)
    # ('match', <unbound method LeafPattern.match>)
    # ('match_seq', <unbound method LeafPattern.match_seq>)
    # ('optimize', <unbound method LeafPattern.optimize>)
    def __init__(self, type: float or int or long, content, name: NoneType) -> NoneType
    def _submatch(self, node, results) -> NotImplementedType or bool
    def match(self, node, results: dict<NoneType, object>) -> bool

class NegatedPattern:  # TODO(pludemann): class NegatedPattern(BasePattern):
    # NegatedPattern ('content', None)
    # NegatedPattern ('name', None)
    # NegatedPattern ('type', None)
    # NegatedPattern ('type_repr', property)
    # ('__init__', <unbound method NegatedPattern.__init__>)
    # ('__repr__', <unbound method NegatedPattern.__repr__>)
    # ('generate_matches', <unbound method NegatedPattern.generate_matches>)
    # ('match', <unbound method NegatedPattern.match>)
    # ('match_seq', <unbound method NegatedPattern.match_seq>)
    # ('optimize', <unbound method NegatedPattern.optimize>)
    def __init__(self, content) -> NoneType
    def generate_matches(self, nodes) -> generator
    def match(self, node) -> bool
    def match_seq(self, nodes) -> bool

class Node:  # TODO(pludemann): class Node(Base):
    # ('children', ())
    # ('next_sibling', property)
    # ('parent', None)
    # ('prefix', property)
    # ('prev_sibling', property)
    # ('type', None)
    # ('type_repr', property)
    # ('was_changed', False)
    # ('was_checked', False)
    # ('__eq__', <unbound method Node.__eq__>)
    # ('__init__', <unbound method Node.__init__>)
    # ('__ne__', <unbound method Node.__ne__>)
    # ('__repr__', <unbound method Node.__repr__>)
    # ('__str__', <unbound method Node.__str__>)
    # ('__unicode__', <unbound method Node.__unicode__>)
    # ('_eq', <unbound method Node._eq>)
    # ('_prefix_getter', <unbound method Node._prefix_getter>)
    # ('_prefix_setter', <unbound method Node._prefix_setter>)
    # ('append_child', <unbound method Node.append_child>)
    # ('changed', <unbound method Node.changed>)
    # ('clone', <unbound method Node.clone>)
    # ('depth', <unbound method Node.depth>)
    # ('descend_to', <unbound method Node.descend_to>)
    # ('get_lineno', <unbound method Node.get_lineno>)
    # ('get_prefix', <unbound method Node.get_prefix>)
    # ('get_suffix', <unbound method Node.get_suffix>)
    # ('insert_child', <unbound method Node.insert_child>)
    # ('label_nodes', <unbound method Node.label_nodes>)
    # ('leaves', <unbound method Node.leaves>)a
    # ('post_order', <unbound method Node.post_order>)
    # ('pre_order', <unbound method Node.pre_order>)
    # ('remove', <unbound method Node.remove>)
    # ('replace', <unbound method Node.replace>)
    # ('set_child', <unbound method Node.set_child>)
    # ('set_prefix', <unbound method Node.set_prefix>)
    # def __repr__(self) -> str  # TODO(pludemann): missing
    def __init__(self, type: float or int or long, children, context, prefix, fixers_applied: dict<slice, dict<?, ?>>) -> NoneType
    def __init__(self, type: NoneType or float or int or long, children: list<Node>, fixers_applied: NoneType or dict<slice, object>) -> NoneType
    def __init__(self, type: float or int or long, children, context) -> NoneType
    def _eq(self, other) -> bool
    def _prefix_getter(self) -> object
    def _prefix_setter(self, prefix) -> NoneType
    def append_child(self, child: Node) -> NoneType
    def changed(self: Base or Leaf or Node) -> NoneType
    def clone(self) -> Node
    def insert_child(self, i, child) -> NoneType  # TODO(pludemann): def insert_child(self, i: bool or int, child) -> NoneType
    def post_order(self) -> generator
    def pre_order(self) -> generator
    def set_child(self, i: bool or int, child) -> NoneType

class NodePattern:
    # NodePattern ('content', None)
    # NodePattern ('name', None)
    # NodePattern ('type', None)
    # NodePattern ('type_repr', property)
    # NodePattern ('wildcards', False)
    # ('__init__', <unbound method NodePattern.__init__>)
    # ('__repr__', <unbound method NodePattern.__repr__>)
    # ('_submatch', <unbound method NodePattern._submatch>)
    # ('generate_matches', <unbound method NodePattern.generate_matches>)
    # ('match', <unbound method NodePattern.match>)
    # ('match_seq', <unbound method NodePattern.match_seq>)
    # ('optimize', <unbound method NodePattern.optimize>)
    def __init__(self, name) -> NoneType
    def __init__(self, type: float or int or long, content, name) -> NoneType
    def _submatch(self, node, results: dict<object, object>) -> bool

class WildcardPattern:
    # WildcardPattern ('content', None)
    # WildcardPattern ('name', None)
    # WildcardPattern ('type', None)
    # WildcardPattern ('type_repr', property)
    # ('__init__', <unbound method WildcardPattern.__init__>)
    # ('__repr__', <unbound method WildcardPattern.__repr__>)
    # ('_bare_name_matches', <unbound method WildcardPattern._bare_name_matches>)
    # ('_iterative_matches', <unbound method WildcardPattern._iterative_matches>)
    # ('_recursive_matches', <unbound method WildcardPattern._recursive_matches>)
    # ('generate_matches', <unbound method WildcardPattern.generate_matches>)
    # ('match', <unbound method WildcardPattern.match>)
    # ('match_seq', <unbound method WildcardPattern.match_seq>)
    # ('optimize', <unbound method WildcardPattern.optimize>)
    def __init__(self, content: nothing, min: float or int or long, max: float or int or long, name) -> NoneType
    def __init__(self, content: tuple<object> or tupleiterator<object>, min: float or int or long, max: float or int or long, name) -> NoneType
    def _bare_name_matches(self, nodes: nothing) -> tuple<int or dict<object, object>>
    def _iterative_matches(self, nodes) -> generator
    def _recursive_matches(self, nodes, count) -> generator
    def generate_matches(self, nodes) -> generator
    def match(self, node, results: dict<nothing, object>) -> bool
    def match_seq(self, nodes, results) -> bool
    def match_seq(self, nodes: list<object>, results: dict<nothing, object>) -> bool
    def optimize(self) -> object
